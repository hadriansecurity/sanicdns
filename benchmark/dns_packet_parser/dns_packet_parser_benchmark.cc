#include <benchmark/benchmark.h>
#include <iostream>
#include <string>
#include <string.h>
#include <vector>
#include <memory>
#include <stdlib.h>
#include <chrono>
#include "dns_packet_parser.h"
#include <rte_eal.h>
#include <rte_ether.h>

using namespace std::literals;

#define NUM_PACKETS_TO_PARSE 200000

// Some valid DNS packets to parse
static const std::vector<std::string> raw_packets = 
{

    "\xbc\xd0\x74\x17\xbe\x44\x26\x5a\x4c\x53\x36\x7e\x08\x00\x45\x00" \
    "\x00\x53\xc1\x2f\x40\x00\x40\x11\xf5\x67\xc0\xa8\x01\x01\xc0\xa8" \
    "\x01\xb1\x00\x35\xfb\xb3\x00\x3f\x9d\x81\x22\x13\x81\x80\x00\x01" \
    "\x00\x01\x00\x00\x00\x01\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f" \
    "\x6d\x00\x00\x01\x00\x01\xc0\x0c\x00\x01\x00\x01\x00\x00\x00\x08" \
    "\x00\x04\x8e\xfa\xb3\x8e\x00\x00\x29\x10\x00\x00\x00\x00\x00\x00\x00"s,

    "\xbc\xd0\x74\x17\xbe\x44\x26\x5a\x4c\x53\x36\x7e\x08\x00\x45\x00" \
    "\x00\x80\x60\x98\x40\x00\x40\x11\x55\xd2\xc0\xa8\x01\x01\xc0\xa8" \
    "\x01\xb1\x00\x35\xca\xa6\x00\x6c\x2c\x87\x6e\xd5\x81\x80\x00\x01" \
    "\x00\x02\x00\x00\x00\x01\x04\x74\x65\x73\x74\x03\x65\x74\x76\x07" \
    "\x74\x75\x64\x65\x6c\x66\x74\x02\x6e\x6c\x00\x00\x01\x00\x01\xc0" \
    "\x0c\x00\x05\x00\x01\x00\x00\x02\x3c\x00\x18\x07\x65\x74\x76\x73" \
    "\x65\x72\x76\x03\x65\x74\x76\x07\x74\x75\x64\x65\x6c\x66\x74\x02" \
    "\x6e\x6c\x00\xc0\x31\x00\x01\x00\x01\x00\x00\x02\x3c\x00\x04\x83" \
    "\xb4\x7d\x56\x00\x00\x29\x10\x00\x00\x00\x00\x00\x00\x00"s,

    "\xbc\xd0\x74\x17\xbe\x44\x26\x5a\x4c\x53\x36\x7e\x08\x00\x45\x00" \
    "\x01\x69\x3e\x1f\x40\x00\x40\x11\x77\x62\xc0\xa8\x01\x01\xc0\xa8" \
    "\x01\xb1\x00\x35\xf8\x66\x01\x55\x73\xe0\xa6\x88\x81\x80\x00\x01" \
    "\x00\x01\x00\x04\x00\x09\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f" \
    "\x6d\x00\x00\x06\x00\x01\xc0\x0c\x00\x06\x00\x01\x00\x00\x00\x01" \
    "\x00\x26\x03\x6e\x73\x31\xc0\x0c\x09\x64\x6e\x73\x2d\x61\x64\x6d" \
    "\x69\x6e\xc0\x0c\x1b\x8e\xcc\xd5\x00\x00\x03\x84\x00\x00\x03\x84" \
    "\x00\x00\x07\x08\x00\x00\x00\x3c\xc0\x0c\x00\x02\x00\x01\x00\x00" \
    "\x29\x04\x00\x06\x03\x6e\x73\x34\xc0\x0c\xc0\x0c\x00\x02\x00\x01" \
    "\x00\x00\x29\x04\x00\x06\x03\x6e\x73\x32\xc0\x0c\xc0\x0c\x00\x02" \
    "\x00\x01\x00\x00\x29\x04\x00\x06\x03\x6e\x73\x33\xc0\x0c\xc0\x0c" \
    "\x00\x02\x00\x01\x00\x00\x29\x04\x00\x02\xc0\x28\xc0\x28\x00\x01" \
    "\x00\x01\x00\x05\x2b\x67\x00\x04\xd8\xef\x20\x0a\xc0\x28\x00\x1c" \
    "\x00\x01\x00\x05\x40\xac\x00\x10\x20\x01\x48\x60\x48\x02\x00\x32" \
    "\x00\x00\x00\x00\x00\x00\x00\x0a\xc0\x6c\x00\x01\x00\x01\x00\x05" \
    "\x40\xac\x00\x04\xd8\xef\x22\x0a\xc0\x6c\x00\x1c\x00\x01\x00\x05" \
    "\x2f\xe9\x00\x10\x20\x01\x48\x60\x48\x02\x00\x34\x00\x00\x00\x00" \
    "\x00\x00\x00\x0a\xc0\x5a\x00\x01\x00\x01\x00\x05\x43\x12\x00\x04" \
    "\xd8\xef\x26\x0a\xc0\x5a\x00\x1c\x00\x01\x00\x05\x3e\x28\x00\x10" \
    "\x20\x01\x48\x60\x48\x02\x00\x38\x00\x00\x00\x00\x00\x00\x00\x0a" \
    "\xc0\x7e\x00\x01\x00\x01\x00\x05\x2d\x40\x00\x04\xd8\xef\x24\x0a" \
    "\xc0\x7e\x00\x1c\x00\x01\x00\x05\x3e\x28\x00\x10\x20\x01\x48\x60" \
    "\x48\x02\x00\x36\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x29\x10" \
    "\x00\x00\x00\x00\x00\x00\x00"s,

    "\xbc\xd0\x74\x17\xbe\x44\x26\x5a\x4c\x53\x36\x7e\x08\x00\x45\x00" \
    "\x00\xb0\xab\x69\x40\x00\x40\x11\x0a\xd1\xc0\xa8\x01\x01\xc0\xa8" \
    "\x01\xb1\x00\x35\xf2\x08\x00\x9c\x96\x48\x8d\xde\x81\x80\x00\x01" \
    "\x00\x01\x00\x00\x00\x05\x06\x67\x6f\x6f\x67\x6c\x65\x03\x63\x6f" \
    "\x6d\x00\x00\x0f\x00\x01\xc0\x0c\x00\x0f\x00\x01\x00\x00\x01\x0b" \
    "\x00\x09\x00\x0a\x04\x73\x6d\x74\x70\xc0\x0c\xc0\x2a\x00\x01\x00" \
    "\x01\x00\x00\x01\x2c\x00\x04\x8e\xfa\x66\x1a\xc0\x2a\x00\x01\x00" \
    "\x01\x00\x00\x01\x2c\x00\x04\x8e\xfa\x66\x1b\xc0\x2a\x00\x1c\x00" \
    "\x01\x00\x00\x01\x2c\x00\x10\x2a\x00\x14\x50\x40\x25\x04\x02\x00" \
    "\x00\x00\x00\x00\x00\x00\x1a\xc0\x2a\x00\x1c\x00\x01\x00\x00\x01" \
    "\x2c\x00\x10\x2a\x00\x14\x50\x40\x25\x04\x02\x00\x00\x00\x00\x00" \
    "\x00\x00\x1b\x00\x00\x29\x10\x00\x00\x00\x00\x00\x00\x00"s,

    "\xbc\xd0\x74\x17\xbe\x44\x26\x5a\x4c\x53\x36\x7e\x08\x00\x45\x00" \
    "\x00\x75\x5b\x3f\x40\x00\x40\x11\x5b\x36\xc0\xa8\x01\x01\xc0\xa8" \
    "\x01\xb1\x00\x35\xd8\x67\x00\x61\x39\x88\x55\x86\x81\x80\x00\x01" \
    "\x00\x01\x00\x00\x00\x01\x02\x32\x36\x03\x31\x30\x32\x03\x32\x35" \
    "\x30\x03\x31\x34\x32\x07\x69\x6e\x2d\x61\x64\x64\x72\x04\x61\x72" \
    "\x70\x61\x00\x00\x0c\x00\x01\xc0\x0c\x00\x0c\x00\x01\x00\x00\x09" \
    "\x6e\x00\x15\x09\x72\x62\x2d\x69\x6e\x2d\x66\x32\x36\x05\x31\x65" \
    "\x31\x30\x30\x03\x6e\x65\x74\x00\x00\x00\x29\x10\x00\x00\x00\x00" \
    "\x00\x00\x00"s
};

class MyFixture : public benchmark::Fixture {
public:
    size_t total_bytes;
    rte_mempool* mbuf_pool;
    rte_mempool* mbuf_pool_out;
    std::unique_ptr<rte_mbuf* []> mbufs;

    void SetUp(const ::benchmark::State& state) {
        // Reset RNG
        srand(0);
        
        // Make Mempool to store packets
        mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", NUM_PACKETS_TO_PARSE, 0, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());
        mbuf_pool_out = rte_pktmbuf_pool_create("MBUF_POOL_OUT", 1000, 0, 512, DNSPacketParser::mbuf_size, rte_socket_id());

        if(mbuf_pool == NULL || mbuf_pool_out == NULL)
            throw std::runtime_error("Couldn't allocate mempools");

        mbufs = std::make_unique<rte_mbuf* []>(NUM_PACKETS_TO_PARSE);
        
        if(mbufs == NULL)
            throw std::runtime_error("Couldn't allocate vector for mbufs");

        if(rte_pktmbuf_alloc_bulk(mbuf_pool, mbufs.get(), NUM_PACKETS_TO_PARSE))
            throw std::runtime_error("Couldn't allocate mbufs");

        // Keep track of the total bytes parsed
        total_bytes = 0;

        // Fill mbufs with some random Ipv4 packets to parse
        for(size_t i = 0; i < NUM_PACKETS_TO_PARSE; i++)
        {
            const std::string& random_pkt = raw_packets[rand() % raw_packets.size()];

            mbufs[i]->packet_type = RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4_EXT | RTE_PTYPE_L4_UDP;
            mbufs[i]->l2_len = sizeof(rte_ether_hdr);
            mbufs[i]->l3_len = sizeof(rte_ipv4_hdr);
            mbufs[i]->l4_len = sizeof(rte_udp_hdr);
            mbufs[i]->data_len = random_pkt.length();
            mbufs[i]->pkt_len = random_pkt.length();
            mbufs[i]->nb_segs = 1;

            char* pkt_data = rte_pktmbuf_mtod(mbufs[i], char*);
            memcpy(pkt_data, random_pkt.c_str(), random_pkt.length());

            total_bytes += random_pkt.length();
        }
    }

    void TearDown(const ::benchmark::State& state) {
        rte_mempool_free(mbuf_pool_out);
        rte_mempool_free(mbuf_pool);
    }
};

BENCHMARK_DEFINE_F(MyFixture, BM_ParseIpv4Packet)(benchmark::State& state) {
    for(auto _ : state)
    {
        auto start = std::chrono::high_resolution_clock::now();

        for(size_t i = 0; i < NUM_PACKETS_TO_PARSE; i++)
        {
            rte_mbuf* parsed_pkt;
            DNSParseResult res = DNSPacketParser::ParseDNSPacketMbuf(mbufs[i], mbuf_pool_out, parsed_pkt);
            if(unlikely(res != DNSParseResult::Succes || parsed_pkt == NULL))
                throw std::runtime_error("Parse failure");
            
            DNSPacketParser::FreeDNSPacketMbuf(parsed_pkt);
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed_seconds =
        std::chrono::duration_cast<std::chrono::duration<double>>(
            end - start);

        state.SetIterationTime(elapsed_seconds.count());

        double packets_per_second = (double)NUM_PACKETS_TO_PARSE / elapsed_seconds.count();
        double gbytes_per_second = (double)(total_bytes) / (elapsed_seconds.count() * 1e9);

        state.counters.insert({{"Pkts/s", packets_per_second},
                                {"GBytes/s", gbytes_per_second}});
    }
}

BENCHMARK_REGISTER_F(MyFixture, BM_ParseIpv4Packet)->UseManualTime();

int main(int argc, char** argv) {                                     
    ::benchmark::Initialize(&argc, argv);
    if (::benchmark::ReportUnrecognizedArguments(argc, argv)) return 1;

    rte_eal_init(argc, argv);

    ::benchmark::RunSpecifiedBenchmarks();

    rte_eal_cleanup();

    ::benchmark::Shutdown();
    return 0;
  }